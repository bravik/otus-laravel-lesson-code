<?php

declare(strict_types=1);

namespace App\Services;

use App\Providers\AppServiceProvider;

/**
 * Начинаем проектировать новую фичу с интерфейса и фокусируемся на бизнес логике.
 * Дальше пишем тесты для бизнес логики, подсовываая Mock-реализации интерфейса.
 * Только после этого начинает реализовывать инфраструктурные зависимости.
 *
 * Интерфейс для отправки уведомлений - часть бизнес логики
 * Реализация - часть инфраструктуры
 *
 * Мы имеем 3 реализации:
 * - EmailNotifier - непосредственно отправляет email
 * - QueuedNotifier - вместо отправки в реальном времени, добавляет задание в очередь
 *              что позволяет не блокировать основной поток выполнения, а так же убедится,
 *              что сообщение будет действительно отправлено, несмотря на ошибки соединения.
 *              точнее что будет как минимум N попыток отправки, прежде чем система откажется
 *              Запустить обработку очереди можно командой:
 *                  make cli
 *                  php artisan queue:work
 * - FilteredNotifier - реализует паттерн "Декоратор" (https://refactoring.guru/ru/design-patterns/decorator))
 *             позволяет добавить дополнительную логику перед отправкой уведомления
 *              В нашем случаае это фильтрация сообщений на спам и на предмет блокировки юзера.
 *              Сам FilteredNotifier занимается только фильтрацией и не отправляет сообщение,
 *                  а делегирует это действие вложенному NotifierInterface.
 *
 * Кому какой сервис подсунуть (внедрить) решает наша конфигурация DI контейнера в @see AppServiceProvider
 */
interface NotifierInterface
{
    public function send(string $text, int $recipientId): void;
}
